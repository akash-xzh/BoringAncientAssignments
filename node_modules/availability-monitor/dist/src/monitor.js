'use strict';
import { EventEmitter } from 'events';
import WebProtocolHander from './protocols/web.js';
import TcpProtocolHander from './protocols/tcp.js';
import { MonitorError } from './protocols/index.js';
const ProtocolHandlers = {
    'web': new WebProtocolHander(),
    'tcp': new TcpProtocolHander(),
};
export class Monitor extends EventEmitter {
    // Options
    protocol;
    protocolOptions;
    interval;
    _intervalHandler;
    _intervalHandlerTicking;
    constructor(opts, runImmediately = true) {
        super();
        this.protocol = opts.protocol;
        this.protocolOptions = opts.protocolOptions;
        this.interval = opts.interval ?? 30000; // User-specified or 30 Seconds default
        this._intervalHandler = null;
        this._intervalHandlerTicking = false;
        this.start(runImmediately);
    }
    get isTicking() {
        return this._intervalHandlerTicking;
    }
    resetState() {
        if (this._intervalHandler) {
            clearInterval(this._intervalHandler);
        }
        this._intervalHandler = null;
        this._intervalHandlerTicking = false;
    }
    start(force = false) {
        if (this._intervalHandlerTicking && !force) {
            return;
        }
        this._intervalHandlerTicking = true;
        // Ping on start
        this.emit('start', this);
        this.ping();
        // create an interval for regular pings
        this._intervalHandler = setInterval(() => { this.ping(); }, this.interval);
    }
    stop() {
        this.resetState();
        this.emit('stop', this);
    }
    restart() {
        this.emit('restart', this);
        this.stop();
        this.start();
    }
    ping() {
        process.nextTick(async () => {
            try {
                const response = await ProtocolHandlers[this.protocol].ping(this.protocolOptions);
                this.emit(response.event, this, response);
            }
            catch (err) {
                if (err instanceof MonitorError) {
                    this.emit(err.response.event, this, err.response);
                }
                else {
                    // Unexpected errors raised in MonitorHandler. Theoretically, should never get here!
                    // Wrap the error in a MonitorResponse object, so event listeners can handle the error
                    // similarly to how expected errors are handled.
                    const response = {
                        event: 'error',
                        isUp: false,
                        duration: 0,
                        error: err
                    };
                    this.emit(response.event, this, response);
                }
            }
            finally {
                this.emit('ping', this);
                await Promise.resolve();
            }
        });
    }
}
//# sourceMappingURL=monitor.js.map