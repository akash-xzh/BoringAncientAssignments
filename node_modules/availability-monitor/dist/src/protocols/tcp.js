'use strict';
import { Socket } from 'net';
import * as utils from '../utils.js';
import { MonitorError } from './index.js';
export default class TcpProtocolHandler {
    async ping(options) {
        let reaction = false;
        let protocolHandlerResponse = {
            isUp: false,
            event: 'down',
            duration: 0
        };
        let socket = new Socket();
        socket.setTimeout(options.options?.timeout ?? 15000);
        let startTime = process.hrtime.bigint();
        socket.connect(options.port, options.host, () => {
            let endTime = process.hrtime.bigint();
            let responseTime = utils.nanoToMilliseconds(endTime - startTime);
            reaction = true;
            socket.destroy();
            protocolHandlerResponse.isUp = true;
            protocolHandlerResponse.duration = responseTime;
            protocolHandlerResponse.data = socket;
            protocolHandlerResponse.event = 'up';
        });
        socket.once('error', (err) => {
            let endTime = process.hrtime.bigint();
            let responseTime = utils.nanoToMilliseconds(endTime - startTime);
            reaction = true;
            socket.destroy();
            protocolHandlerResponse.isUp = false;
            protocolHandlerResponse.duration = responseTime;
            protocolHandlerResponse.event = 'error';
            protocolHandlerResponse.error = err;
        });
        socket.once('timeout', () => {
            let endTime = process.hrtime.bigint();
            let responseTime = utils.nanoToMilliseconds(endTime - startTime);
            reaction = true;
            socket.destroy();
            protocolHandlerResponse.isUp = false;
            protocolHandlerResponse.duration = responseTime;
            protocolHandlerResponse.event = 'timeout';
            protocolHandlerResponse.error = new Error('connection timeout');
        });
        while (!reaction) {
            await utils.sleep(100);
        }
        if (protocolHandlerResponse.error) {
            throw new MonitorError(protocolHandlerResponse);
        }
        else {
            return protocolHandlerResponse;
        }
    }
}
//# sourceMappingURL=tcp.js.map